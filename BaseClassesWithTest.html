<html>
<head>
<script type="text/javascript">

//A Print function for testing. Modify as desired for debug output.  
function print(string)
{
  document.getElementById("demo").innerHTML += "<p>" + string + "</p>";
}
function print_clear()
{
  document.getElementById("demo").innerHTML = "";
}


// Class Need
// We define a need as a group of resources which are all needed *simultainiously*
// for a defed perios of time.  For each resource needed, a quantity can also be defined.
// Support for multiple independant requirements 
function Need(resource, duration, startTime, quantity)
{
  //Initial variables:
  this.resource  = resource;//required input.
  this.duration  = duration  !== undefined ? duration  : 1;//duration default is 1.
  this.startTime = startTime !== undefined ? startTime : 0;//startTime default is 0.
  this.quantity  = quantity  !== undefined ? quantity  : 1;//quantity default is 1.(some resources ignore quantity)
  
  //Convenience functions:
  this.getEndTime = function() { return this.startTime + this.duration; }
  
  //Function that returns a string version of the need.
  this.string = function(){
    return "(Res=" + this.resource + " Start=" + this.startTime + 
      " Duration=" + this.duration + " Quantity=" + this.quantity + ")";
  }

//End of Class Need.
}


// Class Allocation
// The opposite of a Need. It includes the process being allocated to as well as 
// the specific resource, and the quantity and duration of the allocation.
function Allocation(resource, duration, process, quantity)
{
  //Initial variables:
  this.resource = resource;  // not optional. 
  this.duration = duration;  // not optional. 
  this.process  = process;   // not optional. 
  this.quantity = quantity  !== undefined ? quantity  : 1;//quantity default is 1.(some resources ignore quantity)

//End of Class Allocation
}




// Class Process
function Process(needList, arrivalTime, pID)
{ 
  // A static var/function to provide process IDs to new process objects.  
  if (typeof _staticNextId === 'undefined'){ _staticNextId = 0; }
  var nextUniqueID = function() { return _staticNextId++; };
  
  // Assign initial parameters:
  //Core Parameters:
  this.needList    = needList    !== undefined ? needList    : [ new Need("CPU",1000,0) ]; // Default is to just need 1000 cycles of CPU. 
  this.arrivalTime = arrivalTime !== undefined ? arrivalTime : 0;                          // Default Arrival time is 0. 
  this.pID         = pID         !== undefined ? pID         : nextUniqueID();             // pID Default is nextUniqueID. 
  this.progress    = 0; // The process's internal progress meter. Initialize to 0. 
  this.terminated  = false;
  
  
  //Metric variables:
  this.waitDuration      = 0;   // Total time spent waiting for resources. 
  this.firstProgressTime = -1;  // The sim-clock time at which the process was first scheduled. 
  this.finishTime        = -1;  // Inidacates the process is finished. Remember to clear if adding new needs.
  
  //Metric functions:
  this.getWaitDuration = function(){ return this.waitDuration; }
  this.getFirstProgressTime = function(){ return (this.firstProgressTime != -1) ? this.firstProgressTime : "no response"; }
  this.getTurnAroundTime = function() { return (this.finishTime != -1 ) ? (this.finishTime - this.firstProgressTime) : "not finshed"; }
  this.getRunDuration = function() { return this.progress; }
  this.getTotalRunDuration = function() { 
    var retVal = 0; // Find the max start+duration time among the processes needs.  
    for(ii in this.needList){ if (this.needList[ii].getEndTime()  > retVal) { retVal = this.needList[ii].getEndTime(); }    }
    return retVal;
  }
  this.isFinished = function () { return this.progress >= this.getTotalRunDuration(); }
  this.hasTerminated = function() { return this.terminated; }  

    
  
  // Returns a list of Need objects; these are the process's internal
  // needs both filtered and offset based on the current progress-time. 
  this.currentNeeds = function()
  {
    var retVal = [];
    // If current progress is within the duration of a Need, add it to the list. 
    for (ii in this.needList){
      var need = this.needList[ii];
      if (need.startTime  <= this.progress && this.progress <  need.startTime + need.duration ){
        retVal.push( new Need(need.resource, need.startTime + need.duration - this.progress) );
      }
    }
    return retVal;
  }
  
  // Returns the amount of progress-time that the process currently
  // needs with the specified resource.
  this.currentNeed = function(resource)
  {
    var needs = this.currentNeeds();
    for(ii in needs){
      var need = needs[ii];
      if (need.resource === resource)
      {  return need.duration; }
    }
    return undefined;
  }
    
  
  // Returns the progress-time until the next new need arrives in this process.
  this.timeTillNextEvent = function()
  {
    var retVal = 32000000; //should be MAX_INT
    for (ii in this.needList){
      var need = this.needList[ii];
      if (0 < (need.startTime - this.progress) && (need.startTime - this.progress) < retVal)
      { retVal = need.startTime - this.progress; }
    }
    //print("DEBUG: P"+this.pID+": timeTillNextEvent returning "+ retVal +".");
    return retVal;
  }
  
  
  //Returns the amount of progress made by the application with these resources.  
  // (0 if the resources given don't meet the processes current need) 
  this.meetNeeds = function(allocList, time)
  {    
    allocList = allocList !== undefined ? allocList : []; // AllocList defaults to an empty array. 
    //The time parameter is optional. If it's not set, we use the minimum duration in allocList. 
    if (time === undefined){
      time = 32000000;
      for(ii in allocList){
        var alloc = allocList[ii];
        if (alloc.duration < time)
        {  time = alloc.duration; }
      }
      print ("WARNING:P"+this.pID+": No time specified with allocations! Using the minimum duration in allocList: " + time);
    }
    //print("DEBUG: P"+this.pID+": meetNeeds, allocations="+allocList.length+" time="+time+".");
    
    if ( this.hasTerminated() ) { 
      print ("WARNING:P"+this.pID+": This Process has already terminated and doesn't need any more allocations.");
      return allocList; 
    }
    
    
    // Make sure the resource beeing provided is the same as
    // the resource we actually wanted to be scheduled.  
    var needs = this.currentNeeds();
    var match = new Array(needs.length);
    for(nn = 0; nn < needs.length; nn++){
      for(aa = 0; aa < allocList.length; aa++){
        if (needs[nn].resource === allocList[aa].resource)
        {  match[nn] = true; }
      }
      if (match[nn] !== true){
        // We are missing a resource! No progress, return 0.
        this.waitDuration += time;
        print("P"+this.pID+":meetNeeds: No progress. Missing resource: " + needs[nn].resource + ". Total time waiting=" + this.waitDuration);        
        return [ "BLOCKED" ];     
      }
    }
    
    //We have all the resources we need. Now determine how much progress is made. 
    // This should usually be "time", but it could be shorter if a new need starts 
    // between (progress) and (progress + time).
    var newProgress = time;     
    if (this.timeTillNextEvent() < time){
      print("WARNING: P"+this.pID+":meetNeeds: New need arriving before time="+time+" Limiting progress to "+this.timeTillNextEvent()+" cycles.");    
      newProgress = this.timeTillNextEvent();
    }
    
    //At this point in the function we know we will increment progress since we have all needed resources.
    if (needs.length > 0){
      print("P"+this.pID+": Got all "+needs.length+" needed resources and made "+newProgress+" cycles of progress.");   }
    else {
      print("P"+this.pID+": Does not need any resources right now.  Made "+newProgress+" cycles of progress waiting."); }
    // Check if we should record firstProgressTime. 
    if (this.progress === 0 && newProgress > 0){
      this.firstProgressTime = this.waitDuration;
    }
    this.progress += newProgress; // Actually Increment progress by newProgress.
    // Check if we should record finishTime.  
    if (this.finishTime === -1 && this.isFinished()){
      this.finishTime = this.progress + this.waitDuration; 
      this.terminated = true;
    }
    
    //Finally check to see if we can release any resources.
    var retVal = [];
    for(ii in needs){
      var need = needs[ii];
      //print ("DEBUG: Release check:" + need.string() + "  newProgress=" + newProgress);
      if (need.duration <= newProgress){
        print("P"+this.pID+": releasing "+need.resource+".");
        retVal.push(need.resource);
      }
    }
    //print("DEBUG:meetNeeds. Returning:" + retVal);
    return retVal;
  }
  

  
  
// End of Class Process
}




// Class Resource
function Resource(name)
{
  this.name = name; // The name is not optional. Every resource needs one.
  this.waitingQueue = [];

  
  
  // Return true if the specified process is already waiting for or using this resource.
  this.processInQueue = function(process)
  {
    //Default is to search this.waitingQueue.
    for (ii in this.waitingQueue){ 
      var proc = this.waitingQueue[ii];
      if (proc === process){
        return ii;
      }
    }
    return -1;
  }
  
  
  // Call when a process requests a resource.
  // The default addProcess function adds a process to the waiting queue.
  this.addProcess = function(process)
  {
    //Default FIFO implementation: just append to the waiting queue (if it's not already there) and return. 
    if (this.processInQueue(process) < 0){
      print("Resource "+this.name+": Adding P"+process.pID+" to waiting queue.");
      this.waitingQueue.push(process);
    }
    return undefined;
  }
  
  
  // Call when a process volontarily releases a resource. 
  // The default removeProcess simply removes a process from the waiting queue.
  this.removeProcesses = function(processes)
  {
    //Default FIFO implementation: just remove from the waiting queue (if it's there) and return.
    for(ii in processes){
      var process = processes[ii];
      var jj = this.processInQueue(process); // Find out if process is in list, and if so where. 
      if (jj >= 0){
        print("Resource "+this.name+": Removing P"+process.pID+" to waiting queue.");
        this.waitingQueue.splice(jj,1); //splice out the element fount at ii. 
      }
    }
    return undefined;
  }  
  
  
  // Return the time until the next forseeable scheduling event on this resource.
  this.timeTillNextEvent = function()
  {
    var retVal = 32000000
    //Default FIFO implementation: return how much more time the currently scheduled process needs.
    if (this.waitingQueue.length){
      retVal = this.waitingQueue[0].currentNeed(this.name);
    }
    //print("DEBUG:Resource "+this.name+" timeTillNextEvent returning "+ retVal +".");
    return retVal;
  }

  
  // Returns a list of the current allocations for this resource.
  // Each allocation indicates a process and details about the resource allocaed.
  this.currentAllocations = function()
  {
    //Default FIFO implementation: 
    if (this.waitingQueue.length){
      print("Resource "+this.name+": Allocating "+this.timeTillNextEvent()+" cycles to P"+this.waitingQueue[0].pID+".");
      return [ new Allocation(this.name, this.timeTillNextEvent(), this.waitingQueue[0]) ];
    }
    return undefined;
  }  

// End of Class Resource
}




// Class Simulator
function Simulator(processList, resourceList)
{
  // Initial parameters:
  // If we don't specify anything, just throw a few default objects in the lists.
  this.processList  = processList  !== undefined ? processList   :  [new Process(), new Process()];
  this.resourceList = resourceList !== undefined ? resourceList  :  [new Resource("CPU")];
  this.terminatedProcessList = [];
  this.simulatorClock = 0; // Start the simulator wide clock at 0.
  
  print("Simulator initialized with "+this.processList.length+" processes and "+this.resourceList.length+" resources." );
  
  
  
  //getProcess - gets a process by ID.  
  this.getProcess = function(pID)
  {
    for (ii in this.processList){
      var proc = this.processList[ii];
      if (proc.pID === pID){
        return proc;
      }
    }
    print("WARNING:Process "+pID+" not found.  ");
    return undefined;
  }
  
  //getResource - gets a resource by name.
  this.getResource = function(name)
  {
    //print("DEBUG:getResource: name=" + name + " list=" + this.resourceList);
    for (ii in this.resourceList){
      var res = this.resourceList[ii];
      if (res.name === name){
        return res;
      }
    }
    print("WARNING:Resource "+name+" not found.  ");
    return undefined;
  }
  
  
  // The big function that moves time forward to the next event.
  this.simNextEvent = function()
  {
    print("Simulator: Enter simNextEvent.");
  
    //1.) Go through each process, ask it it's current needs, then
    // notify each resource of the processes that need it. 
    for (ii in this.processList){ 
      var proc = this.processList[ii];
      var needs = proc.currentNeeds();
      for (jj in needs ){ 
        var need = needs[jj];
        this.getResource(need.resource).addProcess(proc);
      }
    }
  
    //2.) Now find the time till the next event.  We check both the process
    //  and resource lists for the shortest timeTillNextEvent. 
    var nextEventTime = 32000000;
    for (ii in this.processList){ //First check processList
      var time = this.processList[ii].timeTillNextEvent();
      if (time < nextEventTime){
        nextEventTime = time;
      }
    }
    for (ii in this.resourceList){ //Then check resourceList
      var time = this.resourceList[ii].timeTillNextEvent();
      if (time < nextEventTime){
        nextEventTime = time;
      }
    }
    if (nextEventTime === 32000000){
      print ("Simulator: No more events found! This simulation is over!");
      return 0;
    }
  
    print("Simulator: Time till next event is " + nextEventTime + ".");
  
    //3.) Now that we have nextEventTime, we need to get allocations from every resource. 
    // We'll accumulate them in lists by process.
    var allocDict = {};
    for (ii in this.resourceList){
      var allocs = this.resourceList[ii].currentAllocations();
      for (jj in allocs){
        var alloc = allocs[jj];
        //If this is the first allocation for this process, then create the list entry for its pID.
        if (allocDict[alloc.process.pID] === undefined){
          allocDict[alloc.process.pID] = [ alloc ];
        } else { // If we already have resources for this process, add this one to the list. 
          allocDict[alloc.process.pID].push(alloc);
        }
      }
    }
    //4.) Now we have all the allocations in lists by pID.  Send them out to the processes!
    // The processes will return lists of resources to release.  
    var releaseDict = {};
    var processesWithAllocations = 0;
    for (var ii=0; ii < this.processList.length; ii++){
        var proc = this.processList[ii];
        processesWithAllocations++;
        //Call meetNeeds: we pass in allocations and get out names of resources to be released.
        var releases = proc.meetNeeds(allocDict[proc.pID], nextEventTime);
        //Put the releases in buckets by resource name, just like we did with allocations by pID.
        for(jj in releases){
          var release = releases[jj];
          //print("DEBUG: P"+proc.pID+" released "+release+".");
          if (releaseDict[release] === undefined){
            releaseDict[release] = [ proc ];
          } else {
            releaseDict[release].push(proc);
          }
        }
        //Finally, check if the process has terminated:
        if (proc.hasTerminated()){
          print("Simulator: P"+proc.pID+" has terminated.  Moving to terminated process list.");
          this.terminatedProcessList.push(proc); // Add to terminated list.
          this.processList.splice(ii,1);       // Remove from the active list. 
          ii--; //Must decrement ii to avoid skipping a process.
        }
    }
    //4.5) Check for deadlock - meetNeeds returns special ID "BLOCKED" if it can't make progress. 
    // If all processes with resources are blocked, then we may be in a deadlock.  
    if (releaseDict["BLOCKED"] !== undefined && releaseDict["BLOCKED"].length === processesWithAllocations){
      print("Simulator: No allocated process can make any progress!  Simulation ends in deadlock!!");
      print("For now, return 0 to terminate simulation. When we have resources with preemption this will change.");
      return 0;
    }
    
    //5.) Now we have all the releases in lists by resource name.  Send them out to the resources!
    for (ii in this.resourceList){
      var res = this.resourceList[ii];
      if(releaseDict[res.name] !== undefined){
        res.removeProcesses(releaseDict[res.name]);
      }
    }
    
    this.simulatorClock += nextEventTime; // Start the simulator wide clock at 0.
    print("Simulator: Exit simNextEvent. time passed="+nextEventTime+" Clock="+this.simulatorClock+".");
    
    return nextEventTime;
  }
  
  
//End of Class Simulator
}





function mainTest1()
{  
print_clear();
print("Simulation #1: Successful FIFO Scheduling of 2 resources.");  
  SIM = new Simulator(
    [new Process([ new Need("CPU",210,0), new Need("IO",440,0) ]), 
     new Process([ new Need("CPU",620,0), new Need("IO",250,0)]), 
     new Process([ new Need("CPU",430,0), new Need("IO",260,0)]), 
     new Process([ new Need("CPU",250,0), new Need("IO",250,0)])], 
    [new Resource("CPU"), new Resource("IO")] );

}

function mainTest2()
{   
print_clear();
print("Simulation #2: Deadlock with 2 resources.");  
  SIM = new Simulator(
    [new Process([ new Need("CPU",508,0),   new Need("IO",320,240) ]), 
     new Process([ new Need("CPU",643,230), new Need("IO",407,123)]), 
     new Process([ new Need("CPU",440,100),   new Need("IO",220,100)]), 
     new Process([ new Need("CPU",250,0),   new Need("IO",250,0)])], 
    [new Resource("CPU"), new Resource("IO")] );

}

function nextEvent()
{
   SIM.simNextEvent();
   print("--------------------");
}

function printMetrics()
{
  print("Active processes:");
  for(ii in SIM.processList){ p = SIM.processList[ii];
    print("P"+p.pID+": Response Time="+p.getFirstProgressTime()+", Waiting Time="+p.getWaitDuration()+
      ", Running Time="+p.getRunDuration()+".");
  }
  print("Finished processes:");
  for(ii in SIM.terminatedProcessList){ p = SIM.terminatedProcessList[ii];
    print("P"+p.pID+": Response Time="+p.getFirstProgressTime()+", Waiting Time="+p.getWaitDuration()+
      ", Running Time="+p.getRunDuration()+", Turn Around Time="+p.getTurnAroundTime()+".");
  }
  
}


</script>
</head>
<body>

<h1>Javascript Object Test</h1>
<p id="demo"> </p>

<button type="button" onclick="mainTest1()">Initialize Test 1</button>
<button type="button" onclick="mainTest2()">Initialize Test 2</button>
<button type="button" onclick="nextEvent()">Next Event</button>
<button type="button" onclick="printMetrics()">Process Metrics</button>

</body>
</html> 
