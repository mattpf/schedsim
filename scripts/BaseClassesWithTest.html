<html>
<head>
<script type="text/javascript">

//A Print function for testing. Modify as desired for debug output.  
function print(string)
{
  document.getElementById("demo").innerHTML += "<p>" + string + "</p>";
}


// Class Need
// We define a need as a group of resources which are all needed *simultainiously*
// for a defed perios of time.  For each resource needed, a quantity can also be defined.
// Support for multiple independant requirements 
function Need(resource, duration, startTime, quantity)
{
  //Initial variables:
  this.resource  = resource;//required input.
  this.duration  = duration  !== undefined ? duration  : 1;//duration default is 1.
  this.startTime = startTime !== undefined ? startTime : 0;//startTime default is 0.
  this.quantity  = quantity  !== undefined ? quantity  : 1;//quantity default is 1.(some resources ignore quantity)
  
  //Function that returns a string version of the need.
  this.string = function(){
    return "(Res=" + this.resource + " Start=" + this.startTime + 
	  " Duration=" + this.duration + " Quantity=" + this.quantity + ")";
  }

//End of Class Need.
}


// Class Allocation
// The opposite of a Need. It includes the process being allocated to as well as 
// the specific resource, and the quantity and duration of the allocation.
function Allocation(resource, duration, process, quantity)
{
  //Initial variables:
  this.resource = resource;  // not optional. 
  this.duration = duration;  // not optional. 
  this.process  = process;   // not optional. 
  this.quantity = quantity  !== undefined ? quantity  : 1;//quantity default is 1.(some resources ignore quantity)

//End of Class Allocation
}




// Class Process
function Process(needList, pID)
{
  // A static var/function to provide process IDs to new process objects.  
  if (typeof _staticNextId === 'undefined'){ _staticNextId = 0; }
  var nextUniqueID = function() { return _staticNextId++; };

  // Assign initial parameters:
  
  this.pID = pID !== undefined ? pID : nextUniqueID(); // pID Default is nextUniqueID.
  //Default value for needList is simply 1000 cycles of CPU
  this.needList = needList !== undefined ? needList : [ new Need("CPU",1000,0) ]; 

  // The process's internal progress meter. Initialize to 0.  
  this.progress = 0; 
  
	
  // Returns a list of Need objects; these are the process's internal
  // needs both filtered and offset based on the current progress-time. 
  this.currentNeeds = function()
  {
    if (this.needList.length){
	  retVal = [];
	  // If current progress is within the duration of a Need, add it to the list. 
	  for (ii in this.needList){
	    var need = this.needList[ii];
	    if (need.startTime  <= this.progress && this.progress <  need.startTime + need.duration ){
		  retVal.push( new Need(need.resource, need.startTime + need.duration - this.progress) );
		}
	  }
	  return retVal;
	}
	// If the need queue is empty, ask to terminate. 
	return [ new Need("TERMINATE") ];
  }
  
  // Returns the amount of progress-time that the process currently
  // needs with the specified resource.
  this.currentNeed = function(resource)
  {
    var needs = this.currentNeeds();
	for(ii in needs){
	  var need = needs[ii];
	  if (need.resource === resource)
	  {  return need.duration; }
	}
	return undefined;
  }
	
  
  // Returns the progress-time until the next new need arrives in this process.
  this.timeTillNextEvent = function()
  {
    var retVal = 32000000; //should be MAX_INT
    for (ii in this.needList){
	  var need = this.needList[ii];
      if (0 < (need.startTime - this.progress) && (need.startTime - this.progress) < retVal)
	  { retVal = need.startTime - this.progress; }
	}
	print("DEBUG:Process "+this.pID+" timeTillNextEvent returning "+ retVal +".");
	return retVal;
  }
  
  
  //Returns the amount of progress made by the application with these resources.  
  // (0 if the resources given don't meet the processes current need) 
  this.meetNeeds = function(allocList, time)
  {    
    //The time parameter is optional. If it's not set, we use the minimum duration in allocList. 
	if (time === undefined){
	  var time = 32000000;
	  for(ii in allocList){
	    var alloc = allocList[ii];
	    if (alloc.duration < time)
		{  time = alloc.duration; }
	  }
	}
    print("DEBUG:Process "+this.pID+" meetNeeds, allocations="+allocList.length+" time="+time+".");
    
	// Make sure the resource beeing provided is the same as
	// the resource we actually wanted to be scheduled.  
	var needs = this.currentNeeds();
	var match = new Array(needs.length);
	for(nn = 0; nn < needs.length; nn++){
	  for(aa = 0; aa < allocList.length; aa++){
	    if (needs[nn].resource === allocList[aa].resource)
		{  match[nn] = true; }
	  }
	  // We are missing a resource! No progress, return 0.
	  if (match[nn] !== true){
	    print("P"+this.pID+":meetNeeds: No progress. Missing resource " + needs[nn].resource + ".\n");
	    return 0;	  
	  }
	}
	
	//We have all the resources we need. Now determine how much progress is made. 
	// This should usually be "time", but it could be shorter if a new need starts 
	// between (progress) and (progress + time).
    var newProgress = time; 	
	if (this.timeTillNextEvent() < time){
	  print("P"+this.pID+":meetNeeds: New need arriving before time="+time+
	  " Limiting progress to "+this.getTimeTillNextEvent()+" cycles.");	  
	  newProgress = this.getTimeTillNextEvent();
	}
	
	//Increment progress by newProgress.
	print("Process "+this.pID+" met all needs and made "+newProgress+" cycles of progress.");
	this.progress += newProgress;
	
	//Finally check to see if we can release any resources.
	var retVal = [];
	for(ii in needs){
	  var need = needs[ii];
	  //print ("DEBUG: Release check:" + need.string() + "  newProgress=" + newProgress);
	  if (need.duration <= newProgress){
	    print("Process "+this.pID+" releasing "+need.resource+".");
	    retVal.push(need.resource);
	  }
	}
	//print("DEBUG:meetNeeds. Returning:" + retVal);
	return retVal;
  }
  

  
  
// End of Class Process
}




// Class Resource
function Resource(name)
{
  this.name = name; // The name is not optional. Every resource needs one.
  this.waitingQueue = [];

  
  
  // Return true if the specified process is already waiting for or using this resource.
  this.processInQueue = function(process)
  {
    //Default is to search this.waitingQueue.
    for (ii in this.waitingQueue){ 
	  var proc = this.waitingQueue[ii];
	  if (proc === process){
	    return ii;
	  }
	}
    return -1;
  }
  
  
  // Call when a process requests a resource.
  // The default addProcess function adds a process to the waiting queue.
  this.addProcess = function(process)
  {
    //Default FIFO implementation: just append to the waiting queue (if it's not already there) and return. 
	if (this.processInQueue(process) < 0){
	  print("Resource:"+this.name+". Adding P"+process.pID+" to waiting queue.");
      this.waitingQueue.push(process);
	}
	return undefined;
  }
  
  
  // Call when a process volontarily releases a resource. 
  // The default removeProcess simply removes a process from the waiting queue.
  this.removeProcesses = function(processes)
  {
    //Default FIFO implementation: just remove from the waiting queue (if it's there) and return.
	for(ii in processes){
	  var process = processes[ii];
      var jj = this.processInQueue(process); // Find out if process is in list, and if so where. 
	  if (jj >= 0){
        print("Resource:"+this.name+". Removing P"+process.pID+" to waiting queue.");
        this.waitingQueue.splice(jj,1); //splice out the element fount at ii. 
	  }
	}
	return undefined;
  }  
  
  
  // Return the time until the next forseeable scheduling event on this resource.
  this.timeTillNextEvent = function()
  {
    var retVal = 32000000
    //Default FIFO implementation: return how much more time the currently scheduled process needs.
    if (this.waitingQueue.length){
	  retVal = this.waitingQueue[0].currentNeed(this.name);
	}
	print("DEBUG:Resource "+this.name+" timeTillNextEvent returning "+ retVal +".");
    return retVal;
  }

  
  // Returns a list of the current allocations for this resource.
  // Each allocation indicates a process and details about the resource allocaed.
  this.currentAllocations = function()
  {
    //Default FIFO implementation: 
	if (this.waitingQueue.length){
	  print("Resource:"+this.name+". Allocating "+this.timeTillNextEvent()+" cycles to P"+this.waitingQueue[0].pID+".");
      return [ new Allocation(this.name, this.timeTillNextEvent(), this.waitingQueue[0]) ];
	}
	return undefined;
  }  

// End of Class Resource
}




// Class Simulator
function Simulator(processList, resourceList)
{
  // Initial parameters:
  // If we don't specify anything, just throw a few default objects in the lists.
  this.processList  = processList  !== undefined ? processList  : [new Process(), new Process()];
  this.resourceList = resourceList !== undefined ? resourceList : [new Resource("CPU")];
  this.simulatorClock = 0; // Start the simulator wide clock at 0.
  
  print("Simulator initialized with "+this.processList.length+" processes and "+this.resourceList.length+" resources." );
  
  //getProcess - gets a process by ID.  
  this.getProcess = function(pID)
  {
    for (ii in this.processList){
	  var proc = this.processList[ii];
	  if (proc.pID === pID){
	    return proc;
      }
	}
	print("WARNING:Process "+pID+" not found.  ");
	return undefined;
  }
  
  //getResource - gets a resource by name.
  this.getResource = function(name)
  {
    //print("DEBUG:getResource: name=" + name + " list=" + this.resourceList);
    for (ii in this.resourceList){
	  var res = this.resourceList[ii];
	  if (res.name === name){
	    return res;
      }
	}
	print("WARNING:Resource "+name+" not found.  ");
	return undefined;
  }
  
  
  
  
  // The big function that moves time forward to the next event.
  this.simNextEvent = function()
  {
    print("Simulator: Enter simNextEvent.");
  
    //1.) Go through each process, ask it it's current needs, then
	// notify each resource of the processes that need it. 
    for (ii in this.processList){ 
	  var proc = this.processList[ii];
	  var needs = proc.currentNeeds();
	  for (jj in needs ){ 
	    var need = needs[jj];
		this.getResource(need.resource).addProcess(proc);
	  }
	}
  
    //2.) Now find the time till the next event.  We check both the process
	//  and resource lists for the shortest timeTillNextEvent. 
	var nextEventTime = 32000000;
	for (ii in this.processList){ //First check processList
	  var time = this.processList[ii].timeTillNextEvent();
	  if (time < nextEventTime){
	    nextEventTime = time;
	  }
	}
	for (ii in this.resourceList){ //Then check resourceList
	  var time = this.resourceList[ii].timeTillNextEvent();
	  if (time < nextEventTime){
	    nextEventTime = time;
	  }
	}
  
  
    //3.) Now that we have nextEventTime, we need to get allocations from every resource. 
	// We'll accumulate them in lists by process.
	var allocDict = {};
  	for (ii in this.resourceList){
	  var allocs = this.resourceList[ii].currentAllocations();
	  for (jj in allocs){
	    var alloc = allocs[jj];
		//If this is the first allocation for this process, then create the list entry for its pID.
		if (allocDict[alloc.process.pID] === undefined){
		  allocDict[alloc.process.pID] = [ alloc ];
		} else { // If we already have resources for this process, add this one to the list. 
		  allocDict[alloc.process.pID].push(alloc);
		}
	  }
	}
	//4.) Now we have all the allocations in lists by pID.  Send them out to the processes!
	// The processes will return lists of resources to release.  
	var releaseDict = {};
	for (ii in this.processList){
	  var proc = this.processList[ii];
	  if(allocDict[proc.pID] !== undefined){
	    //Call meetNeeds: we pass in allocations and get out names of resources to be released.
	    var releases = proc.meetNeeds(allocDict[proc.pID], nextEventTime);
		//Put the releases in buckets by resource name, just like we did with allocations by pID.
		for(jj in releases){
		  var release = releases[jj];
		  //print("DEBUG: P"+proc.pID+" released "+release+".");
		  if (releaseDict[release] === undefined){
		    releaseDict[release] = [ proc ];
          } else {
		    releaseDict[release].push(proc);
		  }
		}
	  }
	}
    //5.) Now we have all the releases in lists by resource name.  Send them out to the resources!
    for (ii in this.resourceList){
	  var res = this.resourceList[ii];
	  if(releaseDict[res.name] !== undefined){
	    res.removeProcesses(releaseDict[res.name]);
	  }
	}
	
	this.simulatorClock += nextEventTime; // Start the simulator wide clock at 0.
	print("Simulator: Exit simNextEvent. time passed="+nextEventTime+" Clock="+this.simulatorClock+".");
  }
  
  
//End of Class Simulator
}





function mainTest()
{  
  var SIM = new Simulator(
    [new Process([ new Need("CPU",200,0)  , new Need("IO",200,0) ]), 
	 new Process([ new Need("CPU",600,0)  , new Need("IO",200,0)]), 
	 new Process([ new Need("CPU",400,400), new Need("IO",200,0)]), 
	 new Process([ new Need("CPU",250,250), new Need("IO",200,0)])], 
    [new Resource("CPU"), new Resource("IO")] );
  
  SIM.simNextEvent();
  SIM.simNextEvent();
  SIM.simNextEvent();
  SIM.simNextEvent();
  SIM.simNextEvent();

  
}


</script>
</head>
<body>

<h1>Javascript Object Test</h1>
<p id="demo"> </p>

<button type="button" onclick="mainTest()">Run mainTest</button>

</body>
</html> 
